#!/bin/sh

#    DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
#                    Version 2, December 2004
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long
# as the name is changed.
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.


# Builds with gcc.  Could work with others, but IDK if they provide the
# profiler and debugging info.

name=$(basename "$PWD")
src_file='main.c'
binary_file='main'
app_image_file="$name-$(uname -m).AppImage"

CFLAGS="-Wall -Wextra -Werror -rdynamic $CFLAGS"

if [ -f jcc.env ]; then
    . $PWD/jcc.env
fi

cmd="$1"
if [ -z "$cmd" ]; then
    #cmd='run'
    cmd='run-appimage'
fi

log() {
    [ -z "$LOG" ] || echo "LOG: $1" >&2
}

build() {
    extra_flags="$1"
    log "extra_flags: $extra_flags"

    log 'build'
    time -f 'compile: %e seconds' gcc $CFLAGS $extra_flags -o "$binary_file" "$src_file" $lib_flags
}

debug() {
    log 'debug'
    build '-Og -g' && gdb "$binary_file"
}

profile() {
    log 'profile'
    build '-fprofile-arcs -pg' && "./$binary_file" $run_args
    gprof --brief "$binary_file" gmon.out > "$binary_file.profile"
}

run() {
    log 'run'
    build '-Og' && ./"$binary_file" $run_args
}

gup()
{
    git pull && git submodule sync && git submodule update --init --recursive
}

check_app_dir()
{
    if [ ! -d AppDir/res ]; then
        mkdir -p AppDir/res \
            && echo "[Desktop Entry]\nName=$name\nExec=AppRun\nIcon=app\nType=Application\nCategories=Network;\nTerminal=true\n\nX-AppImage-Version=0.1\n" > "AppDir/app.desktop" \
            && cp fu/tools/default-logo.png AppDir/app.png \
            && touch AppDir/res/main.css \
            && touch AppDir/res/main.js
    fi
}

# currently directly saving images here, but should it be possible to delete
# the AppDir and have it rebuilt?  If an image atlas is used that would need to
# be generated, etc as part of the build?  generating multiple resolutions
# of a high res source?
appimage() {
    log 'appimage'
    build '-Og' &&
        cp "$binary_file" AppDir/AppRun &&
        ./fu/tools/appimagetool-x86_64.AppImage AppDir/
}

run_appimage() {
    export FU_DEV="$USER"

    log 'run_appimage'
    appimage && ./"$app_image_file" $run_args
}

# eventually should download the latest and build a static lib
# needs -pthread -ldl for lib_flags
update_sqlite() {
    gcc -c -DSQLITE_ENABLE_RTREE=1 -o sqlite3.o sqlite3.c
    # TODO(jason): I think this is probably unnecessary and the sqlite3.o could
    # be provided the same way instead
    ar rcs libsqlite3.a sqlite3.o
}

clean() {
    log 'clean'
    [ ! -e "$binary_file" ] || rm "$binary_file"
    rm -f gmon.out "$binary_file.profile" main.gcda

    exit 0
}

check_app_dir

if [ "$cmd" = 'build' ]; then
    build
elif [ "$cmd" = 'appimage' ]; then
    appimage
elif [ "$cmd" = 'run-appimage' ]; then
    run_appimage
elif [ "$cmd" = 'clean' ]; then
    clean
elif [ "$cmd" = 'debug' ]; then
    debug
elif [ "$cmd" = 'profile' ]; then
    profile
elif [ "$cmd" = 'run' ]; then
    run
elif [ "$cmd" = 'gup' ]; then
    gup
elif [ "$cmd" = 'update-sqlite' ]; then
    update_sqlite
else
    # build to /tmp
    name=$(mktemp)
    src_file="$cmd"
    run "$name"
    rm "$name"
fi

